# Infinite Pokédex — Testing Guidelines

This document outlines comprehensive testing strategies for Infinite Pokédex across unit, security, and integration levels. Tests ensure code integrity, security, and full-system functionality before sprint completion. Agents must follow these rules: Run tests after every code change; fix failures before committing; update docs/tests if code changes. Do not edit this file without explicit user instruction—reference it strictly.

## Test Types and Locations
Tests live in `/tests/`, run via `/scripts/test-suite.sh`. Each type has a specific purpose:

- **Unit Tests** (`/tests/unit/`): Test individual functions/modules (client components, server crawlers, data processors). Use Jest for JavaScript testing.
- **Security Tests** (`/tests/security/`): Scan for vulnerabilities (XSS, injection risks, data exposure). Use ESLint-plugin-security, dependency scanning, and manual security tests.
- **Integration Tests** (`/tests/integration/`): End-to-end tests for PWA functionality, AI generation, offline sync, and CDN integration. Use Playwright for browser automation.

## Setup
1. **Install Dependencies**: Run `/scripts/setup.sh` (includes Jest, Playwright, ESLint, security tools).
2. **Sprint Preparation**: At sprint start, review Implementation Plan tasks; create test stubs in relevant folders (e.g., `unit/pokedex.test.js` for Pokédex tasks).
3. **Run All Tests**: `./scripts/test-suite.sh` (runs unit first, then security, then integration).

## Unit Testing

### Client-Side Unit Tests
**Location**: `/tests/unit/client/`  
**Framework**: Jest with jsdom for DOM testing  
**Coverage Target**: 80%+ for all modules

```javascript
// Example: /tests/unit/client/pokedex.test.js
describe('PokedexEntry', () => {
  test('should load species data from IndexedDB', async () => {
    const entry = new PokedexEntry(6); // Charizard
    const data = await entry.loadData();
    expect(data.name).toBe('Charizard');
    expect(data.types).toContain('Fire');
  });

  test('should generate lore with WebLLM', async () => {
    const entry = new PokedexEntry(6);
    const lore = await entry.generateLore();
    expect(lore).toHaveLength(5); // 5 panels
    expect(lore[0]).toHaveProperty('title');
    expect(lore[0]).toHaveProperty('body');
  });

  test('should handle generation errors gracefully', async () => {
    const entry = new PokedexEntry(6);
    // Mock WebLLM failure
    jest.spyOn(entry, 'runWebLLM').mockRejectedValue(new Error('Model failed'));
    const result = await entry.generateLore();
    expect(result).toBeDefined(); // Should return fallback
  });
});
```

### Server-Side Unit Tests
**Location**: `/tests/unit/server/`  
**Framework**: Jest with Node.js environment  
**Coverage Target**: 80%+ for all modules

```javascript
// Example: /tests/unit/server/crawler.test.js
describe('BulbapediaCrawler', () => {
  test('should respect robots.txt', async () => {
    const crawler = new BulbapediaCrawler();
    const canCrawl = await crawler.checkRobotsTxt();
    expect(canCrawl).toBe(true);
  });

  test('should parse Pokémon data correctly', async () => {
    const crawler = new BulbapediaCrawler();
    const data = await crawler.parseSpeciesPage('Charizard');
    expect(data.name).toBe('Charizard');
    expect(data.types).toEqual(['Fire', 'Flying']);
    expect(data.height_m).toBeGreaterThan(0);
  });

  test('should handle rate limiting', async () => {
    const crawler = new BulbapediaCrawler();
    // Mock rate limit response
    jest.spyOn(crawler, 'makeRequest').mockResolvedValue({ status: 429 });
    await expect(crawler.crawlSpecies(6)).rejects.toThrow('Rate limited');
  });
});
```

### AI Generation Unit Tests
**Location**: `/tests/unit/ai/`  
**Framework**: Jest with mocked AI services  
**Coverage Target**: 80%+ for AI integration modules

```javascript
// Example: /tests/unit/ai/webllm.test.js
describe('WebLLM Integration', () => {
  test('should generate lore with correct format', async () => {
    const webllm = new WebLLMWorker();
    const tidbits = [{ title: 'Test Theory', body: 'Test content' }];
    const metadata = { name: 'Charizard', types: ['Fire', 'Flying'] };
    
    const lore = await webllm.generateLore(tidbits, metadata);
    expect(lore).toHaveLength(5);
    expect(lore[0]).toHaveProperty('title');
    expect(lore[0]).toHaveProperty('body');
  });

  test('should handle model loading errors', async () => {
    const webllm = new WebLLMWorker();
    jest.spyOn(webllm, 'loadModel').mockRejectedValue(new Error('Model failed'));
    await expect(webllm.generateLore([], {})).rejects.toThrow('Model failed');
  });
});
```

## Security Testing

### Vulnerability Scanning
**Location**: `/tests/security/`  
**Tools**: ESLint-plugin-security, npm audit, manual testing  
**Target**: Zero high/critical vulnerabilities

```javascript
// Example: /tests/security/xss.test.js
describe('XSS Protection', () => {
  test('should sanitize user input', () => {
    const maliciousInput = '<script>alert("xss")</script>';
    const sanitized = sanitizeInput(maliciousInput);
    expect(sanitized).not.toContain('<script>');
  });

  test('should prevent script injection in lore', () => {
    const lore = { title: '<script>alert("xss")</script>', body: 'Safe content' };
    const sanitized = sanitizeLore(lore);
    expect(sanitized.title).not.toContain('<script>');
  });
});
```

### Data Privacy Testing
**Location**: `/tests/security/privacy.test.js`  
**Focus**: No PII collection, secure data handling

```javascript
describe('Privacy Protection', () => {
  test('should not collect personal data', () => {
    const app = new PokedexApp();
    expect(app.collectsPersonalData()).toBe(false);
  });

  test('should handle data locally only', () => {
    const storage = new IndexedDBWrapper();
    expect(storage.isLocalOnly()).toBe(true);
  });
});
```

## Integration Testing

### PWA Functionality Tests
**Location**: `/tests/integration/pwa.test.js`  
**Framework**: Playwright with mobile device emulation  
**Target**: Full PWA functionality

```javascript
// Example: /tests/integration/pwa.test.js
describe('PWA Functionality', () => {
  test('should install as PWA', async () => {
    const { page } = await browser.newPage();
    await page.goto('http://localhost:3000');
    
    // Check manifest
    const manifest = await page.evaluate(() => navigator.serviceWorker);
    expect(manifest).toBeDefined();
    
    // Test offline functionality
    await page.context().setOffline(true);
    await page.reload();
    await expect(page.locator('.pokedex-container')).toBeVisible();
  });

  test('should sync data from CDN', async () => {
    const { page } = await browser.newPage();
    await page.goto('http://localhost:3000');
    
    // Wait for sync to complete
    await page.waitForSelector('.sync-complete');
    const speciesCount = await page.locator('.pokemon-card').count();
    expect(speciesCount).toBeGreaterThan(0);
  });
});
```

### AI Generation Integration Tests
**Location**: `/tests/integration/ai-generation.test.js`  
**Framework**: Playwright with real device testing  
**Target**: End-to-end AI generation flow

```javascript
describe('AI Generation Flow', () => {
  test('should generate lore and artwork for Pokémon entry', async () => {
    const { page } = await browser.newPage();
    await page.goto('http://localhost:3000');
    
    // Navigate to Charizard entry
    await page.click('[data-species-id="6"]');
    await page.waitForSelector('.pokedex-entry');
    
    // Wait for lore generation
    await page.waitForSelector('.lore-panel', { timeout: 30000 });
    const lorePanels = await page.locator('.lore-panel').count();
    expect(lorePanels).toBe(5);
    
    // Wait for artwork generation
    await page.waitForSelector('.artwork-gallery img', { timeout: 60000 });
    const artworkImages = await page.locator('.artwork-gallery img').count();
    expect(artworkImages).toBeGreaterThan(0);
  });
});
```

### Offline Functionality Tests
**Location**: `/tests/integration/offline.test.js`  
**Framework**: Playwright with network simulation  
**Target**: Complete offline functionality

```javascript
describe('Offline Functionality', () => {
  test('should work completely offline after sync', async () => {
    const { page } = await browser.newPage();
    
    // Initial sync
    await page.goto('http://localhost:3000');
    await page.waitForSelector('.sync-complete');
    
    // Go offline
    await page.context().setOffline(true);
    await page.reload();
    
    // Test offline functionality
    await page.click('[data-species-id="6"]');
    await page.waitForSelector('.pokedex-entry');
    
    // Should be able to generate lore offline
    await page.waitForSelector('.lore-panel');
    const lorePanels = await page.locator('.lore-panel').count();
    expect(lorePanels).toBe(5);
  });
});
```

## Performance Testing

### Load Testing
**Location**: `/tests/performance/load.test.js`  
**Framework**: Playwright with performance metrics  
**Target**: <3s TTI, <2MB bundle size

```javascript
describe('Performance Tests', () => {
  test('should load within performance budget', async () => {
    const { page } = await browser.newPage();
    const startTime = Date.now();
    
    await page.goto('http://localhost:3000');
    await page.waitForSelector('.pokedex-container');
    
    const loadTime = Date.now() - startTime;
    expect(loadTime).toBeLessThan(3000); // 3 seconds
  });

  test('should have acceptable bundle size', async () => {
    const bundleSize = await getBundleSize();
    expect(bundleSize).toBeLessThan(2 * 1024 * 1024); // 2MB
  });
});
```

## Running Tests

### Individual Test Suites
- **Unit Tests**: `npm run test:unit` or `jest tests/unit`
- **Security Tests**: `npm run test:security` or `jest tests/security`
- **Integration Tests**: `npm run test:integration` or `playwright test`
- **Performance Tests**: `npm run test:performance` or `jest tests/performance`

### Full Test Suite
- **All Tests**: `./scripts/test-suite.sh` (runs unit → security → integration → performance)
- **CI/CD**: Tests run automatically on pull requests and main branch

### Sprint-End Validation
- **Pre-commit**: All tests must pass before code can be committed
- **Sprint Completion**: 100% test pass rate required before sprint completion
- **Documentation**: Update `/docs/tests/` with test results and fixes

## Test Maintenance

### Adding New Tests
1. **For New Features**: Create test stubs when starting new tasks
2. **For Bug Fixes**: Add regression tests to prevent reoccurrence
3. **For Refactoring**: Update tests to match new implementation

### Test Documentation
- **Unit Tests**: Document in `/docs/tests/unit.md` with Mermaid diagrams
- **Integration Tests**: Document in `/docs/tests/integration.md` with test scenarios
- **Security Tests**: Document in `/docs/tests/security.md` with vulnerability coverage

### Debugging Failed Tests
1. **Check Logs**: Review test output for specific error messages
2. **Browser Dev Tools**: Use for client-side test debugging
3. **Network Tab**: Check for failed requests in integration tests
4. **Console Output**: Review for JavaScript errors

## Quality Gates

### Before Sprint Completion
1. **Unit Tests**: 80%+ coverage, all tests passing
2. **Security Tests**: Zero high/critical vulnerabilities
3. **Integration Tests**: All user flows working end-to-end
4. **Performance Tests**: Meeting performance budgets
5. **Documentation**: All tests documented and up-to-date

### Before Production Deployment
1. **Full Test Suite**: 100% pass rate
2. **Security Scan**: Clean security audit
3. **Performance Validation**: All performance targets met
4. **Accessibility Testing**: WCAG AA compliance verified
5. **Cross-Browser Testing**: Chrome Android and Safari iOS verified

## Test Environment Setup

### Local Development
```bash
# Install dependencies
./scripts/setup.sh

# Run specific test suite
npm run test:unit
npm run test:security
npm run test:integration

# Run all tests
./scripts/test-suite.sh
```

### CI/CD Environment
- **GitHub Actions**: Automated test runs on pull requests
- **Docker**: Consistent test environment across platforms
- **Parallel Execution**: Tests run in parallel for faster feedback

**Assumptions**: Modern development environment with Node.js v18+, Chrome/Chromium for Playwright.  
**Known Issues**: Some tests may be flaky due to network conditions; we implement retry logic and better error handling.

Agents: Always run tests before committing. Reference Backend Structure for data integrity tests (e.g., sync checks). Update test documentation when adding new tests or fixing failures.
